---
# PRÉ-REQUISITO: defina antes algo como:
# - set_fact:
#     vm_count: 3
#     vm_ids: "{{ range(1, vm_count + 1) | list }}"   # -> [1,2,3]
# Assim, todas as tasks abaixo fazem loop sobre vm_ids.

# =========================
# 1) CRIAR PUBLIC IPs
# =========================
- name: Create Public ip
  delegate_to: localhost            # executa no controlador (não dentro da VM)
  azure.azcollection.azure_rm_publicipaddress:
    resource_group: "{{ resource_group }}"
    allocation_method: Static       # Static = IP fixo no Azure
    name: "pip_instance_{{ item }}" # NOME do recurso (não é o endereço IP!)
    location: "{{ location }}"
  loop: "{{ vm_ids }}"              # <- LOOP: cria pip_instance_1, pip_instance_2, pip_instance_3
  # Dica: manter um padrão ÚNICO de nomes evita confusão nas próximas tasks.

# =========================================
# 2) LER PIPs PARA OBTER O ENDEREÇO (IPv4)
# =========================================
- name: Get Public IP info
  delegate_to: localhost
  azure.azcollection.azure_rm_publicipaddress_info:
    resource_group: "{{ resource_group }}"
    name: "pip_instance_{{ item }}" # deve ser IGUAL ao nome criado acima
  register: pip_results             # <- quando há loop, o resultado fica em pip_results.results (lista)
  loop: "{{ vm_ids }}"
  retries: 10                       # <- alguns segundos até o IP aparecer
  delay: 6
  # Observação:
  # cada item de pip_results.results terá estrutura semelhante a:
  # {
  #   "item": 1,   # índice do loop
  #   "publicipaddresses": [ {"ip_address": "20.x.x.x", ...} ]
  # }

# ========================================
# 3) CRIAR NICs E VINCULAR AO PUBLIC IP
# ========================================
- name: Create Network Interface
  delegate_to: localhost
  azure.azcollection.azure_rm_networkinterface:
    resource_group: "{{ resource_group }}"
    name: "nic_instance{{ item }}"      # ex.: nic_instance1
    virtual_network: "{{ vnet_name }}"
    subnet: "{{ subnet_name }}"
    security_group: "{{ nsg_name }}"
    location: "{{ location }}"
    ip_configurations:
      - name: "ipconfig_{{ item }}"     # nome interno dessa config de IP
        public_ip_address_name: "pip_instance_{{ item }}"  # AQUI vai o NOME do PIP (não o IP)
        private_ip_allocation_method: Dynamic               # IP privado será alocado dinamicamente (DHCP)
  loop: "{{ vm_ids }}"                  # <- LOOP: uma NIC por VM

# ==========================================
# 4) (OPCIONAL) LER NICs PARA PEGAR IP PRIV
# ==========================================
- name: Get NIC info
  delegate_to: localhost
  azure.azcollection.azure_rm_networkinterface_info:
    resource_group: "{{ resource_group }}"
    name: "nic_instance{{ item }}"
  register: nic_results
  loop: "{{ vm_ids }}"
  # Dica: IP privado fica em:
  # nic_results.results[idx].networkinterfaces[0].ip_configurations[0].private_ip_address

# ==============================
# 5) CRIAR AS VMs (instance-N)
# ==============================
- name: Create Instances
  delegate_to: localhost
  azure.azcollection.azure_rm_virtualmachine:
    resource_group: "{{ resource_group }}"
    name: "instance-{{ item }}"     # ex.: instance-1 (use hífen ou underscore, só seja consistente)
    vm_size: "{{ size_instances }}"
    admin_username: "{{ admin_user }}"
    admin_password: "{{ admin_password }}"
    network_interfaces: "nic_instance{{ item }}"  # conecta a NIC correspondente
    image:
      offer: "{{ os_image_offer }}"
      publisher: "{{ os_image_publisher }}"
      sku: "{{ os_image_sku }}"
      version: latest
    managed_disk_type: "{{ managed_disk_type }}"   # ex.: Standard_LRS
    os_disk_caching: ReadWrite
    os_disk_size_gb: 64
    state: present
    location: "{{ location }}"
  register: vm_result
  loop: "{{ vm_ids }}"
  # Pegadinha: o retorno desse módulo não traz o IP público — por isso buscamos via *_info acima.

# ==================================================
# 6) ADD HOST (dinâmico) NO INVENTÁRIO EM MEMÓRIA
# ==================================================
- name: Add instances to inventory
  add_host:
    # IMPORTANTE SOBRE item.item:
    # Em tasks com loop e register anterior (pip_results), cada elemento de pip_results.results
    # tem um campo "item" contendo o índice do loop original (1,2,3...).
    # Por isso usamos item.item aqui para reconstruir o nome "instance_{{ índice }}".
    name: "instance_{{ item.item }}"  # ex.: instance_1
    ansible_host: "{{ item.publicipaddresses[0].ip_address }}"  # IP público resolvido
    ansible_user: "{{ admin_user }}"
    groups: kubernetes               # este é o grupo "em memória" (não grava no arquivo)
  loop: "{{ pip_results.results }}"   # <- LOOP sobre cada retorno do PIP

# ===================================================
# 7) PERSISTIR NO ARQUIVO hosts (inventário em disco)
# ===================================================
# Dica: garanta que exista o cabeçalho [kubernetes] no arquivo hosts.
# Se não existir, rode antes:
# - name: Ensure [kubernetes] header
#   delegate_to: localhost
#   become: true
#   blockinfile:
#     path: "{{ playbook_dir }}/hosts"
#     create: yes
#     block: |
#       [kubernetes]

- name: Add public IPs to hosts file
  delegate_to: localhost
  become: true                       # geralmente necessário se o arquivo está em /data/...
  lineinfile:
    path: "{{ playbook_dir }}/hosts" # caminho do inventário "físico"
    insertafter: "[kubernetes]"      # insere logo após o cabeçalho do grupo
    # regexp garante idempotência: se já existir a linha do host, atualiza em vez de duplicar
    regexp: '^instance_{{ item.item }}\s'
    line: "instance_{{ item.item }} ansible_host={{ item.publicipaddresses[0].ip_address }} ansible_user={{ admin_user }}"
  loop: "{{ pip_results.results }}"
  loop_control:
    # Apenas estética do log: mostra "instance_1 => 20.x.x.x"
    label: "instance_{{ item.item }} => {{ (item.publicipaddresses | first).ip_address }}"
  # Se seu /home (tmp do Ansible) e o destino (hosts) estão em FS diferentes e der erro EXDEV,
  # descomente a linha abaixo para evitar escrita atômica:
  # unsafe_writes: yes

# ==========================================================
# 8) (OPCIONAL) ESCREVER TAMBÉM OS IPs PRIVADOS NO hosts
# ==========================================================
# Observação importante: aqui o loop deve ser sobre nic_results.results,
# e o caminho para o IP privado muda.
# Exemplo (descomentar para usar):
#
# - name: Add private IPs to hosts file
#   delegate_to: localhost
#   become: true
#   lineinfile:
#     path: "{{ playbook_dir }}/hosts"
#     insertafter: "[kubernetes]"
#     regexp: '^instance_{{ item.item }}\s'
#     line: >-
#       instance_{{ item.item }}
#       ansible_host={{ item.networkinterfaces[0].ip_configurations[0].private_ip_address }}
#       ansible_user={{ admin_user }}
#   loop: "{{ nic_results.results }}"
#   loop_control:
#     label: "instance_{{ item.item }} (priv) => {{ item.networkinterfaces[0].ip_configurations[0].private_ip_address }}"

